"""
Rule type implementations.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from enum import IntEnum
from typing import Optional, Any
import logging
import re

from simpleeval import simple_eval, InvalidExpression

from src.data.fetcher import StockData, HistoricalData

logger = logging.getLogger(__name__)


class AlertSeverity(IntEnum):
    """Alert severity levels."""

    INFO = 1
    WARNING = 2
    CRITICAL = 3


@dataclass
class Alert:
    """Alert generated by a rule."""

    ticker: str
    rule_type: str
    message: str
    severity: AlertSeverity
    current_price: float
    triggered_at: datetime
    metadata: dict[str, Any]


class Rule(ABC):
    """Base class for all rules."""

    @abstractmethod
    def evaluate(
        self,
        stock_data: StockData,
        historical_data: Optional[HistoricalData],
    ) -> list[Alert]:
        """
        Evaluate the rule against stock data.

        Returns:
            List of alerts if rule conditions are met, empty list otherwise.
        """
        pass


class MonthlyHighDropRule(Rule):
    """Rule for detecting drops from monthly high."""

    def __init__(self, thresholds: list[float]):
        """
        Initialize monthly high drop rule.

        Args:
            thresholds: List of drop percentages to alert on (e.g., [-5, -10, -15, -20])
        """
        self.thresholds = sorted(thresholds, reverse=True)  # Sort descending

    def evaluate(
        self,
        stock_data: StockData,
        historical_data: Optional[HistoricalData],
    ) -> list[Alert]:
        if historical_data is None:
            return []

        drop_pct = historical_data.drop_from_high(stock_data.current_price)
        alerts = []

        for threshold in self.thresholds:
            if drop_pct <= threshold:
                severity = self._get_severity(threshold)
                alerts.append(
                    Alert(
                        ticker=stock_data.ticker,
                        rule_type="monthly_high_drop",
                        message=self._format_message(
                            stock_data.ticker,
                            stock_data.current_price,
                            historical_data.monthly_high,
                            drop_pct,
                            threshold,
                        ),
                        severity=severity,
                        current_price=stock_data.current_price,
                        triggered_at=datetime.now(),
                        metadata={
                            "threshold": threshold,
                            "monthly_high": historical_data.monthly_high,
                            "drop_pct": drop_pct,
                        },
                    )
                )

        return alerts

    def _get_severity(self, threshold: float) -> AlertSeverity:
        """Determine severity based on threshold."""
        if threshold <= -15:
            return AlertSeverity.CRITICAL
        elif threshold <= -10:
            return AlertSeverity.WARNING
        else:
            return AlertSeverity.INFO

    def _format_message(
        self,
        ticker: str,
        current_price: float,
        monthly_high: float,
        drop_pct: float,
        threshold: float,
    ) -> str:
        """Format alert message."""
        return (
            f"{ticker} dropped {abs(threshold):.0f}% from monthly high. "
            f"Current: ${current_price:.2f}, High: ${monthly_high:.2f} "
            f"(actual drop: {drop_pct:.1f}%)"
        )


class DailyChangeRule(Rule):
    """Rule for detecting significant daily price changes."""

    def __init__(self, threshold: float, direction: str = "both"):
        """
        Initialize daily change rule.

        Args:
            threshold: Minimum absolute percentage change to trigger
            direction: "up", "down", or "both"
        """
        self.threshold = threshold
        self.direction = direction

    def evaluate(
        self,
        stock_data: StockData,
        historical_data: Optional[HistoricalData],
    ) -> list[Alert]:
        change_pct = stock_data.daily_change_pct

        # Check if change meets threshold based on direction
        should_alert = False
        if self.direction == "both" and abs(change_pct) >= self.threshold:
            should_alert = True
        elif self.direction == "up" and change_pct >= self.threshold:
            should_alert = True
        elif self.direction == "down" and change_pct <= -self.threshold:
            should_alert = True

        if not should_alert:
            return []

        is_surge = change_pct > 0
        severity = self._get_severity(abs(change_pct))

        return [
            Alert(
                ticker=stock_data.ticker,
                rule_type="daily_change",
                message=self._format_message(
                    stock_data.ticker,
                    stock_data.current_price,
                    stock_data.previous_close,
                    change_pct,
                    is_surge,
                ),
                severity=severity,
                current_price=stock_data.current_price,
                triggered_at=datetime.now(),
                metadata={
                    "change_pct": change_pct,
                    "threshold": self.threshold,
                    "direction": "up" if is_surge else "down",
                },
            )
        ]

    def _get_severity(self, change_pct: float) -> AlertSeverity:
        """Determine severity based on change magnitude."""
        if change_pct >= 10:
            return AlertSeverity.CRITICAL
        elif change_pct >= 7:
            return AlertSeverity.WARNING
        else:
            return AlertSeverity.INFO

    def _format_message(
        self,
        ticker: str,
        current_price: float,
        previous_close: float,
        change_pct: float,
        is_surge: bool,
    ) -> str:
        """Format alert message."""
        action = "surged" if is_surge else "dropped"
        sign = "+" if is_surge else ""
        return (
            f"{ticker} {action} {sign}{change_pct:.1f}% today. "
            f"Current: ${current_price:.2f}, Previous: ${previous_close:.2f}"
        )


class VolumeSpikeRule(Rule):
    """Rule for detecting volume spikes."""

    def __init__(self, multiplier: float = 3.0, average_days: int = 20):
        """
        Initialize volume spike rule.

        Args:
            multiplier: Volume must exceed average by this factor
            average_days: Number of days to calculate average volume
        """
        self.multiplier = multiplier
        self.average_days = average_days

    def evaluate(
        self,
        stock_data: StockData,
        historical_data: Optional[HistoricalData],
    ) -> list[Alert]:
        if historical_data is None:
            return []

        volume_ratio = historical_data.volume_ratio(stock_data.volume)

        if volume_ratio < self.multiplier:
            return []

        severity = self._get_severity(volume_ratio)

        return [
            Alert(
                ticker=stock_data.ticker,
                rule_type="volume_spike",
                message=self._format_message(
                    stock_data.ticker,
                    stock_data.volume,
                    historical_data.avg_volume_20d,
                    volume_ratio,
                ),
                severity=severity,
                current_price=stock_data.current_price,
                triggered_at=datetime.now(),
                metadata={
                    "volume_ratio": volume_ratio,
                    "current_volume": stock_data.volume,
                    "avg_volume": historical_data.avg_volume_20d,
                },
            )
        ]

    def _get_severity(self, volume_ratio: float) -> AlertSeverity:
        """Determine severity based on volume ratio."""
        if volume_ratio >= 5:
            return AlertSeverity.WARNING
        else:
            return AlertSeverity.INFO

    def _format_message(
        self,
        ticker: str,
        current_volume: int,
        avg_volume: float,
        volume_ratio: float,
    ) -> str:
        """Format alert message."""
        return (
            f"{ticker} volume spike: {volume_ratio:.1f}x average. "
            f"Current: {current_volume:,.0f}, Avg: {avg_volume:,.0f}"
        )


class CustomRule(Rule):
    """User-defined custom rule with expression evaluation."""

    # Allowed variable names
    ALLOWED_VARS = {
        "price",
        "open",
        "high",
        "low",
        "close",
        "volume",
        "avg_volume_20",
        "monthly_high",
        "monthly_low",
        "daily_change_pct",
    }

    def __init__(self, name: str, condition: str):
        """
        Initialize custom rule.

        Args:
            name: Human-readable rule name
            condition: Expression to evaluate (e.g., "price < 150")

        Raises:
            ValueError: If condition syntax is invalid
        """
        self.name = name
        self.condition = condition
        self._validate_condition(condition)

    def _validate_condition(self, condition: str) -> None:
        """Validate condition syntax."""
        # Check for disallowed patterns (potential exploits)
        disallowed = ["__", "import", "exec", "eval", "open", "file"]
        for pattern in disallowed:
            if pattern in condition.lower():
                raise ValueError(f"Invalid condition: contains disallowed pattern '{pattern}'")

        # Check for valid characters only
        allowed_pattern = r'^[\w\s\d\.\+\-\*\/\<\>\=\!\(\)\_]+$'
        if not re.match(allowed_pattern, condition):
            raise ValueError(f"Invalid condition syntax: {condition}")

        # Try to evaluate with dummy values to check syntax
        try:
            dummy_context = {var: 0 for var in self.ALLOWED_VARS}
            simple_eval(condition, names=dummy_context)
        except InvalidExpression as e:
            raise ValueError(f"Invalid condition syntax: {condition}") from e
        except Exception:
            # Other errors (like division by zero) are OK for syntax validation
            pass

    def evaluate(
        self,
        stock_data: StockData,
        historical_data: Optional[HistoricalData],
    ) -> list[Alert]:
        # Build variable context
        context = {
            "price": stock_data.current_price,
            "open": stock_data.open_price,
            "high": stock_data.high,
            "low": stock_data.low,
            "close": stock_data.previous_close,
            "volume": stock_data.volume,
            "daily_change_pct": stock_data.daily_change_pct,
        }

        if historical_data:
            context.update({
                "avg_volume_20": historical_data.avg_volume_20d,
                "monthly_high": historical_data.monthly_high,
                "monthly_low": historical_data.monthly_low,
            })

        # Safely evaluate expression using simpleeval
        try:
            result = simple_eval(self.condition, names=context)
        except Exception as e:
            logger.warning(f"Failed to evaluate custom rule '{self.name}': {e}")
            return []

        if not result:
            return []

        return [
            Alert(
                ticker=stock_data.ticker,
                rule_type="custom",
                message=f"{self.name}: {stock_data.ticker} at ${stock_data.current_price:.2f}",
                severity=AlertSeverity.INFO,
                current_price=stock_data.current_price,
                triggered_at=datetime.now(),
                metadata={
                    "rule_name": self.name,
                    "condition": self.condition,
                },
            )
        ]
